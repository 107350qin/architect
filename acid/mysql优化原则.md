## 目标级别:type=range / ref

## 单表

### 最佳左前缀，左边失效，右边全部失效（针对复合索引，不针对多个单索引）

### where和order by,使用索引排序而不是文件排序

### 覆盖索引

### 范围in靠后，防止该字段及其后面的索引失效

### 解析时slelect放在where之后

### key_len的计算方式

## 双表

### 小表驱动大表，数据量小的表放在左边

### 一般左外连接，坐标为基准，索引建在做表上；右外连接以右表为基准索引建在右表上。

## 三表

### 跟双表类似，小驱大，在经常长训的字段上建立索引

### 避免索引失效的原则

1. 复合索引

   - 复合索引不要跨列使用或者无序使用
   - 复合索引尽量全索引匹配

2. 不要在索引上进行任何操作（计算，汉书，类型转换），否则索引失效，如果是复合索引则右边全部失效。

3. 复合索引不能使用!=  <>  或者 is/not null，否则自身以及右侧索引全部失效。可能是概率事件。

   一般而言，<,>，in之后的索引失效

   4. 尽量使用索引覆盖

   5. like尽量以常量开头，不以%开头。如果非要%开头则用索引覆盖解决

   6. 尽量不要使用类型转换（显示，隐式），否则失效

   7. or使得索引全部失效

      ### 一些其他的优化方法

      exist in和in,主查询数据集大用in，子查询数据集大用exists

      排序顺序相同

    8. 前缀索引和索引选择性

    9. 合适的列顺序

    10. 反范式化优化

    11. 单路排序和双路排序

    12. 优化排序分：延迟关联



mysql分库分表和分区分表，主从复制，读写分离，锁，隔离级别

